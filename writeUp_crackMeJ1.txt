 ______________________________________________
[                                              ]
[   A SOLUTION FOR the "crackMeJ1" of          ]
[            juansacco   	                   ]
[                                              ]
[  By Akeph from ibn5100  				       ]
[  Our blog: 3lpsyl5ul2ibnjcb.onion            ]
[                                              ]
[ ibn5100x@protonmail.com                      ]
[_________________________________20/01/2019___]


Hi my fellow crackers !
Today we'll solve the "crackMeJ1" made by juansacco (you can find it here: https://crackmes.one/crackme/5c35cda733c5d475210bc563 ).

---------------------------------------------------------------------------------------
Author:
juansacco

Language:
C/C++

Upload:
10:32 AM 01/09/2019

Level:
2        // Okay, that seems to be a pretty easy crackme

Platform
Windows

Description

This is a multi-staged crackme that implements several protections for antidebugging.

Objective: Find the keys ( 3 ) to solve the crackme and make a keygen

Hint: Run it on a VM :-)    // Oh oh !
---------------------------------------------------------------------------------------


Today's music: https://www.youtube.com/watch?v=AvmjOhEBXMo for hardcore punk lovers and https://www.youtube.com/watch?v=jJ74wkYyFKg for the others.

Because we are jedi-masters of cracking, we don't use a VM.

Soooooooooooooo... Let's go !

We disasemble the crackme with ollyDGB2, and run.
Open the string data references menu and click on the "Please type the correct serial number" string.
Enter a number.

Then scroll until the last "What are you looking at? ;-)" string and set a breakpoint on 001A240A (a IsDebuggerPresent call)
So, run (F9 !) and clic on the "TEST EAX, EAX" after the breakpoint (001A2410), then press space and replace the "TEST" by "XOR".

It's a more elegant method to bypass the IsDebuggerPresent protection than patch the jump.
Why does it work ? Because when the call detect a debugger, it sets eax to 1; however 1 xor 1 is 0 (and 0 xor 0 to) so "XOR EAX, EAX" always returns 0, like when there
is no debugger.

(When can see the progam call "system("shutdown")" if a debugger is present, this is probably why the author recommand to run the program on a VM !)

Okay press F8 twice, you should be on a cmp (at 001A2C69). Set a breakpoint here, it compares our number with 1337 (0x539) which is the first key !
Restart the program, enter 1337 and run.

The program asks you the name of your computer.
You can easly find it directly in the debugger, in the string data references.

BUT WAIT !

Set a breakpoint on 001A2CA2 (call 001A12A0) and on 001A2CA7 (call 001A1340), then you can enter your computer's name.
When you're on the breakpoint, press F7 to step into the call.

Scroll until "Nice try... But nope! :-("

001A12F1  /.  8B65 E8       MOV ESP,DWORD PTR SS:[EBP-18]
001A12F4  |.  33C0          XOR EAX,EAX
001A12F6  |>  C745 FC FEFFF MOV DWORD PTR SS:[LOCAL.1],-2
001A12FD  |.  85C0          TEST EAX,EAX
001A12FF  |.  74 29         JZ SHORT 001A132A
001A1301  |. |68 F0341A00   PUSH 001A34F0                            ; /Arg1 = CrackMeJ1.1A34F0, Entry point
001A1306  |. |51            PUSH ECX                                 ; |
001A1307  |. |BA 24621A00   MOV EDX,OFFSET 001A6224                  ; |ASCII "[!] Nice try.. But nope! :-("
001A130C  |. |8B0D 7C601A00 MOV ECX,DWORD PTR DS:[<&MSVCP140.?cout@s ; |
001A1312  |. |E8 891F0000   CALL 001A32A0                            ; |
001A1317  |. |83C4 04       ADD ESP,4                                ; |
001A131A  |. |8BC8          MOV ECX,EAX                              ; |
001A131C  |. |FF15 5C601A00 CALL DWORD PTR DS:[<&MSVCP140.??6?$basic ; \MSVCP140.??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
001A1322  |. |6A FF         PUSH -1
001A1324  |. |FF15 14611A00 CALL DWORD PTR DS:[<&api-ms-win-crt-runt
001A132A  |> \8B4D F0       MOV ECX,DWORD PTR SS:[LOCAL.4]
001A132D  |.  64:890D 00000 MOV DWORD PTR FS:[0],ECX
001A1334  |.  59            POP ECX
001A1335  |.  5F            POP EDI
001A1336  |.  5E            POP ESI
001A1337  |.  5B            POP EBX
001A1338  |.  8BE5          MOV ESP,EBP
001A133A  |.  5D            POP EBP
001A133B  \.  C3            RETN

It's an other protection.
Like you did before, replace the "test eax,eax" by "xor eax,eax" to always jump to 001A132A and continue to the second-key checking.

F9 and jump to 001A2CA7 (the second breakpoint we set just before).
Jump into the call (F7), we can see a little routine which compare our second key with the computer's name.

Run.
Then, the program says that we found the second key and asks you the third and last key.

But it's very very easy, the key is written at 001A1449 "MOV EDX,OFFSET 001A62A4 ; ASCII "nuf-si-gnireenigne-esrever"" (and on the string data references)
However, scroll until the "You won ! Happy cracking !" message. You can see another call to isDebuggerPresent, a "Nice try... but nope !:-(" and a "system("shutdown")".
There is "001A149F  85C0  TEST EAX,EAX", now you know how to bypass this protection.

Then you can enter the third key: nuf-si-gnireenigne-esrever  and... you won !!!
"You won ! Happy cracking !"

That was a pretty fun but very easy crackme.

Bye !